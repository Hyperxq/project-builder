Object.defineProperty(exports,"__esModule",{value:!0}),exports.main=void 0;const e=require("tslib");require("@paralleldrive/cuid2");const t=e.__importDefault(require("ajv")),r=e.__importDefault(require("../../config/config-schema.json")),s=require("@angular-devkit/schematics/tasks"),n=require("../../utils"),a=require("@schematics/angular/utility/parse-name"),o=require("@angular-devkit/core");let c={};function i(e,t,r,o,l,u){const{collection:g,alias:d,ID:p,path:h,settings:m,instances:f,dependsOn:k,children:y,sendPath:w}=o,[v,b]=function(e,t){return t&&c[t]?c[t]:e&&c[e]?c[e]:[]}(r,d);v||g||(n.logger.error(`Error executing ${r} schematic`,[`${r} doesn't have a collection specified`]),process.exit(1)),h&&(t=`${t}/${h}`),l.push(e.addTask(new s.RunSchematicTask("showSchematicInfo",{schematicName:r,collection:g??v}),l));const j=function(e,t,r,o,c,i=[],l=[],u,g){const d=[],{path:p,name:h}=(0,a.parseName)(t,o);n.logger.debug("executeSchematic"+o,{schematicPath:p,name:h}),!p||(t=p);if(0===l.length){n.logger.debug("executeSchematic 0 instances"+o,{dryRun:u,path:t,...c});let a=c;g&&(a={path:t,...c});const l=e.addTask(new s.RunSchematicTask(r,o,a),i);d.push(l)}else for(const n of l){const{path:a,...i}=n;a&&(t=`${t}/${a}`);let l=c;g&&(l={path:t,...c,...i});const u=e.addTask(new s.RunSchematicTask(r,o,l));d.push(u)}return d}(e,t,v??g,r,{...b,...m},l,f,u,w);if(l.push(...j),!y)return l;return Object.entries(y).forEach((([r,s])=>{l.push(...i(e,t,r,s,l,u))})),l}exports.main=function(e){return async(a,l)=>{n.logger.log({level:"info",message:n.colors.bold("âœ¨ Project Builder orchestrator started âœ¨")}),n.logger.warn("ðŸš¸ Warning: if any schematic fails, none of the previously executed ones will take effect");const{saveMode:u,packageManager:g,filePath:d,remoteFile:p,installCollections:h}=e,m=await async function(e,t=!1,r){const s=new n.Spinner("getFile");try{if(s.start(n.colors.blue(`Reading the ${t?"remote":"local"} file`)),t){const t=await fetch(e);return s.succeed("File was successfully read"),await t.json()}{const t=r.read(e);return t?(s.succeed("File was successfully read"),JSON.parse(t.toString())):(s.stop(),void n.logger.error(`Could not find ${e}.`))}}catch(e){s.stop(),n.logger.error(e.message),process.exit(1)}}(d,p,a);if(void 0===m)return a;const f=await async function(e){try{const s=(new t.default).compile(r.default);return!!s(e)||(n.logger.error("The file is not in the correct format",s.errors),!1)}catch(e){n.logger.error("Error during json validation:",[e.message]),process.exit(1)}}(m);if(!f)return a;const{$schema:k,projects:y,collections:w,...v}=m;let b=[];h&&b.push(function(e,t,r,a){try{const n=Object.entries(t).map((([e,t])=>{const{version:r}=t;return{packageName:e,version:r}}));return e.addTask(new s.RunSchematicTask("installCollections",{packages:n,packageManager:r,dryRun:a}))}catch(e){n.logger.error("Something happened when Project Builder was trying to install collections: ",[e.message]),process.exit(1)}}(l,(0,o.deepCopy)(w),g,u)),function(e){const t=Object.entries((0,o.deepCopy)(e));for(const[e,r]of t){const{keepInstalled:t,version:s,...a}=r;for(const[t,r]of Object.entries(a)){const{alias:s}=r;(c[s]||c[t])&&(n.logger.error("Two or more schematics has the same schematic name or alias"),process.exit(1)),c[s??t]=[e,r]}}}((0,o.deepCopy)(w));try{b=function(e,t,r,s){const n=Object.entries(t);return n.forEach((([t,n])=>{r.push(...i(e,"/",t,n??{},[],s))})),r}(l,v,b,u)}catch(e){n.logger.error("Something happened when Project Builder tried to execute schematics",[e.message]),process.exit(1)}n.logger.debug(b),h&&function(e,t,r,a,o){const c=Object.entries(t);n.logger.debug("packageNames to uninstall",t);const i=c.filter((([e,t])=>{const{keepInstalled:r}=t;return void 0===r||!r})).map((([e])=>e));n.logger.debug("packageNames to uninstall",i),e.addTask(new s.RunSchematicTask("uninstallCollections",{packageNames:i,packageManager:r,dryRun:o}),a)}(l,(0,o.deepCopy)(w),g,b,u)}};
